// λa.a (lambda abstraction)
const I = a => a;

// f a        =    f(a)
// f a b      =    f(a)(b)
// f (a b)    =    f(a(b))

// λa.b x     =    a => b(x)
// λa.(b x)   =    a => b(x)
// (λa.b) x   =    (a => b)(x)
// λa.λb.a    =    a => b => a
// λa.(λb.a)  =    a => (b => a)

// Beta reduction

// ((λa.a)λb.λc.b)(x)λe.f
// (λb.λc.b)(x)λe.f
//     λb.λc.b    =   b => c => b
//        λc.x λe.f
//        x
//  x is in B-normal form


// shorthand:
// λa.λb.λc.λb
// λabc.b
// both are the same as a => b => c => b


// (1) Mockingbird ... "identity"
//     M := λf.ff
M => M(M);


// (2) Kestrel .... "const"
//     λab.a
// "fixates on a particular value"
K = a => b => a;


// (3) Kite (Kestrel of identity)
//     λab.b
// "takes 2 arguments, returns the second"
// K(I)(b)(y) = y
KI = a => b => b

// -------------------------------------
//  turing machines & lambda calculus
//  are the same exact things...
// -------------------------------------

// Combinator: λb.b
//             λab.a
// Not comb:   λb.a
//             λa.ab


// (4) Cardinal   λfab.fba
// C(K)(I)(M)
// K(M)(I)
// M
C = f => a => b => f(b)(a)  // Why is it actually applied on right?

// -------------------------------------
// JS:   const result = bool ? exp1 : exp2

// Boolean:
// TRUE := K
// FALSE := KI
T = K
F = KI

// Not:
// λp.pFT
// not(T):
//    T(F)(T) ---> F
// not(F):
//    F(F)(T) ---> T
not = p => p(F)(T)

// And:
// λpq.pqF or λpq.pqp
and = p => q => p(q)(p)

// console.log(and(T)(T));
// console.log(and(T)(F));
// console.log(and(F)(T));
// console.log(and(F)(F));

// Or:
// λpq.pTq or λpq.ppq
or = p => q => p(p)(q);

// console.log(or(T)(T));
// console.log(or(T)(F));
// console.log(or(F)(T));
// console.log(or(F)(F));

// Use of Mockingbird to implement "or"
// (λpq.ppq)xy  -->  xxy
//        Mxy   -->  xxy
// so,

// console.log(M(T)(T));
// console.log(M(T)(F));
// console.log(M(F)(T));
// console.log(M(F)(F));

// Equals:
// λpq.p(qTF)(qFT)




// ----- END OF PART 1: BOOLEAN LOGIC ------


// N0 := λfa.a
// N1 :=  λfa.fa
// N2 := λfa.ffa
zero = f => a => a;
once = f => a => f(a);
twice = f => a => f(f(a));


// Composition:
// Bluebird:
// B   =   λfga.f(ga)
B = f => g => a => f(g(a));


// Successor:
// succ =    λnfa.f(fna)
succ = n => f => a => f(n(f)(a))

// Mult:
// mult =    λnkf.n(kf)
mult = n => k => n(k(f))
// that's just composition!


// Skipping subtraction (for now?)
// pred := λn.FST(nφ(PAIR N0 N0))


// ----------------- Data structures -------------------

// Vireo... (basically a closure that can be accessed with
//           K & KI)
// λabf.fab
vireo = a => b => f => f(a)(b)
// vireo(I)(M)(K) gives you I
// vireo(I)(M)(KI) gives you M
//
// λp.pK
// λp.pKI ... accessing 1st and 2nd of pair


// phi:
// phi = λp.PAIR(snd(p)(succ(snd(p)))
// shifts 2nd thing to 1st thing, increments 2nd thing
